import * as d3 from 'd3';

window.neo = {};

const __hasProp = {}.hasOwnProperty, __slice = [].slice;

const neo = {
  models: {},
  renderers: {
    node: [],
    relationship: []
  },
  utils: {
    copy: src => JSON.parse(JSON.stringify(src)),
    extend: (dest, src) => {
      if (!neo.utils.isObject(dest) && neo.utils.isObject(src)) return;
      for (let k in src) {
        if (!__hasProp.call(src, k)) continue;
        dest[k] = src[k];
      }
      return dest;
    },
    isArray: Array.isArray || function(obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    },
    isObject: obj => Object(obj) === obj
  }
};

const __bind = (fn, me) => { return function(){ return fn.apply(me, arguments); }; };

neo.models.Graph = (() => {
  function Graph(cypher) {
    this.removeRelationships = __bind(this.removeRelationships, this);
    this.removeNodes = __bind(this.removeNodes, this);
    this.findRelationship = __bind(this.findRelationship, this);
    this.findNode = __bind(this.findNode, this);
    this.addRelationships = __bind(this.addRelationships, this);
    this.addNodes = __bind(this.addNodes, this);
    this.nodeMap = {};
    this.relationshipMap = {};
    if (cypher) {
      this.addNodes(cypher.nodes);
      this.addRelationships(cypher.relationships);
    }
  }

  Graph.prototype.nodes = function() {
    const _ref = this.nodeMap;
    const _results = [];
    for (let key in _ref) {
      if (!__hasProp.call(_ref, key)) continue;
      _results.push(_ref[key]);
    }
    return _results;
  };

  Graph.prototype.relationships = function() {
    const _ref = this.relationshipMap;
    const _results = [];
    for (let key in _ref) {
      if (!__hasProp.call(_ref, key)) continue;
      _results.push(_ref[key]);
    }
    return _results;
  };

  Graph.prototype.addNodes = function(item) {
    let _base, _name;
    const items = !neo.utils.isArray(item) ? [item] : item;
    for (let _i = 0, _len = items.length; _i < _len; _i++) {
      item = items[_i];
      const node = !(item instanceof neo.models.Node) ? new neo.models.Node(item.id, item.labels, item.properties) : item;
      (_base = this.nodeMap)[_name = item.id] || (_base[_name] = node);
    }
    return this;
  };

  Graph.prototype.addRelationships = function(item) {
    const items = !neo.utils.isArray(item) ? [item] : item;
    for (let _i = 0, _len = items.length; _i < _len; _i++) {
      item = items[_i];
      const source = this.nodeMap[item.source] || (() => { throw new Error("Invalid source"); })();
      const target = this.nodeMap[item.target] || (() => { throw new Error("Invalid target"); })();
      this.relationshipMap[item.id] = new neo.models.Relationship(item.id, source, target, item.type, item.properties);
    }
    return this;
  };

  Graph.prototype.findNode = id => this.nodeMap[id];

  Graph.prototype.findRelationship = id => this.relationshipMap[id];

  Graph.prototype.merge = result => {
    this.addNodes(result.nodes);
    this.addRelationships(result.relationships);
    return this;
  };

  Graph.prototype.removeNodes = function() {
    let remove = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (arguments.length === 0) {
      this.nodeMap = {};
      this.relationshipMap = {};
      return this;
    }
    remove = neo.utils.isArray(remove[0]) ? remove[0] : remove;
    for (let _i = 0, _len = remove.length; _i < _len; _i++) {
      let id = remove[_i];
      let rels = (() => {
        const _ref = this.relationshipMap;
        const _results = [];
        for (const rId in _ref) {
          if (!__hasProp.call(_ref, rId)) continue;
          const rel = _ref[rId];
          if (rel.source.id === id || rel.target.id === id) {
            _results.push(rel.id);
          }
        }
        return _results;
      }).call(this);
      this.removeRelationships(rels);
      delete this.nodeMap[id];
    }
    return this;
  };

  Graph.prototype.removeRelationships = function() {
    let remove = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (arguments.length === 0) {
      this.relationshipMap = {};
      return this;
    }
    remove = neo.utils.isArray(remove[0]) ? remove[0] : remove;
    for (let _i = 0, _len = remove.length; _i < _len; _i++) {
      const id = remove[_i];
      delete this.relationshipMap[id];
    }
    return this;
  };

  return Graph;
})();

const NeoD3Geometry = (() => {
  const square = distance => distance * distance;

  function NeoD3Geometry(style) {
    this.style = style;
  }

  NeoD3Geometry.prototype.formatNodeCaptions = function(nodes) {
    const style = this.style;
    const _results = [];
    for (let _i = 0, _len = nodes.length; _i < _len; _i++) {
      const node = nodes[_i];
      const template = style.forNode(node).get("caption");
      const captionText = style.interpolate(template, node.id, node.propertyMap);
      const words = captionText.split(" ");
      const lines = [];
      let _j;
      for (let i = _j = 0, _ref = words.length - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; i = 0 <= _ref ? ++_j : --_j) {
        lines.push({ node: node, text: words[i], baseline: (1 + i - words.length / 2) * 10 });
      }
      _results.push(node.caption = lines);
    }
    return _results;
  };

  NeoD3Geometry.prototype.measureRelationshipCaption = function(relationship, caption) {
    const fontFamily = 'sans-serif';
    const fontSize = parseFloat(this.style.forRelationship(relationship).get('font-size'));
    const padding = parseFloat(this.style.forRelationship(relationship).get('padding'));
    return neo.utils.measureText(caption, fontFamily, fontSize) + padding * 2;
  };

  NeoD3Geometry.prototype.captionFitsInsideArrowShaftWidth = function(relationship) {
    return parseFloat(this.style.forRelationship(relationship).get('shaft-width')) > parseFloat(this.style.forRelationship(relationship).get('font-size'));
  };

  NeoD3Geometry.prototype.measureRelationshipCaptions = function(relationships) {
    const _results = [];
    for (let _i = 0, _len = relationships.length; _i < _len; _i++) {
      const relationship = relationships[_i];
      relationship.captionLength = this.measureRelationshipCaption(relationship, relationship.type);
      _results.push(relationship.captionLayout = this.captionFitsInsideArrowShaftWidth(relationship) ? "internal" : "external");
    }
    return _results;
  };

  NeoD3Geometry.prototype.shortenCaption = function(relationship, caption, targetWidth) {
    let shortCaption = caption;
    while (true) {
      if (shortCaption.length <= 2) return ['', 0];
      shortCaption = shortCaption.substr(0, shortCaption.length - 2) + '\u2026';
      const width = this.measureRelationshipCaption(relationship, shortCaption);
      if (width < targetWidth) return [shortCaption, width];
    }
  };

  NeoD3Geometry.prototype.layoutRelationships = function(relationships) {
    let relationship, dx, dy, length;
    const _results = [];
    const alongPath = (from, distance) => {
      return { x: from.x + dx * distance / length, y: from.y + dy * distance / length };
    };

    for (let _i = 0, _len = relationships.length; _i < _len; _i++) {
      relationship = relationships[_i];
      dx = relationship.target.x - relationship.source.x;
      dy = relationship.target.y - relationship.source.y;
      length = Math.sqrt(square(dx) + square(dy));
      relationship.arrowLength = length - relationship.source.radius - relationship.target.radius;
      const shaftRadius = (parseFloat(this.style.forRelationship(relationship).get('shaft-width')) / 2) || 2;
      const headRadius = shaftRadius + 3;
      const headHeight = headRadius * 2;
      const shaftLength = relationship.arrowLength - headHeight;
      relationship.startPoint = alongPath(relationship.source, relationship.source.radius);
      relationship.endPoint = alongPath(relationship.target, -relationship.target.radius);
      relationship.midShaftPoint = alongPath(relationship.startPoint, shaftLength / 2);
      relationship.angle = Math.atan2(dy, dx) / Math.PI * 180;
      relationship.textAngle = relationship.angle;
      if (relationship.angle < -90 || relationship.angle > 90) {
        relationship.textAngle += 180;
      }
      const _ref = shaftLength > relationship.captionLength ? [relationship.type, relationship.captionLength] : this.shortenCaption(relationship, relationship.type, shaftLength);
      relationship.shortCaption = _ref[0];
      relationship.shortCaptionLength = _ref[1];
      if (relationship.captionLayout === "external") {
        const startBreak = (shaftLength - relationship.shortCaptionLength) / 2;
        const endBreak = shaftLength - startBreak;
        _results.push(relationship.arrowOutline = ['M', 0, shaftRadius, 'L', startBreak, shaftRadius, 'L', startBreak, -shaftRadius, 'L', 0, -shaftRadius, 'Z', 'M', endBreak, shaftRadius, 'L', shaftLength, shaftRadius, 'L', shaftLength, headRadius, 'L', relationship.arrowLength, 0, 'L', shaftLength, -headRadius, 'L', shaftLength, -shaftRadius, 'L', endBreak, -shaftRadius, 'Z'].join(' '));
      } else {
        _results.push(relationship.arrowOutline = ['M', 0, shaftRadius, 'L', shaftLength, shaftRadius, 'L', shaftLength, headRadius, 'L', relationship.arrowLength, 0, 'L', shaftLength, -headRadius, 'L', shaftLength, -shaftRadius, 'L', 0, -shaftRadius, 'Z'].join(' '));
      }
    }
    return _results;
  };

  NeoD3Geometry.prototype.setNodeRadii = function(nodes) {
    const _results = [];
    for (let _i = 0, _len = nodes.length; _i < _len; _i++) {
      const node = nodes[_i];
      _results.push(node.radius = parseFloat(this.style.forNode(node).get("diameter")) / 2);
    }
    return _results;
  };

  NeoD3Geometry.prototype.onGraphChange = function(graph) {
    this.setNodeRadii(graph.nodes());
    this.formatNodeCaptions(graph.nodes());
    return this.measureRelationshipCaptions(graph.relationships());
  };

  NeoD3Geometry.prototype.onTick = function(graph) {
    return this.layoutRelationships(graph.relationships());
  };

  return NeoD3Geometry;
})();

neo.graphModel = () => {
  const graph = new neo.models.Graph();

  const model = function() {};

  model.callbacks = {};

  model.trigger = () => {
    const args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    let event = 'updated';
    if (model.callbacks[event]) {
      const _ref = model.callbacks[event];
      const _results = [];
      for (let _i = 0, _len = _ref.length; _i < _len; _i++) {
        const callback = _ref[_i];
        _results.push(callback.apply(null, args));
      }
      return _results;
    }
  };

  model.nodes = items => {
    if (items == null) return graph.nodes();
    graph.removeNodes().addNodes(items);
    model.trigger('nodesAdded');
    return model;
  };

  model.nodes.add = items => {
    if (items != null) {
      graph.addNodes(items);
      model.trigger('nodesAdded');
    }
    return model;
  };

  model.nodes.find = graph.findNode;

  model.nodes.remove = () => {
    graph.removeNodes.apply(null, arguments);
    model.trigger('nodesRemoved');
    return model;
  };

  model.relationships = items => {
    if (items == null) return graph.relationships();
    graph.removeRelationships().addRelationships(items);
    model.trigger('relationshipsAdded');
    return model;
  };

  model.relationships.add = items => {
    if (items != null) {
      graph.addRelationships(items);
      model.trigger('relationshipsAdded');
    }
    return model;
  };

  model.relationships.find = graph.findRelationship;

  model.relationships.remove = () => {
    graph.removeRelationships.apply(null, arguments);
    model.trigger('relationshipsRemoved');
    return model;
  };

  model.on = (event, callback) => {
    let _base = model.callbacks;
    _base[event] = _base[event] != null ? _base[event] : [];
    _base[event].push(callback);
    return model;
  };

  return model;
};

neo.graphView = () => {
  let layout = neo.layout.force();
  const style = neo.style();
  let viz = null;
  const callbacks = {};
  const trigger = () => [];

  const chart = selection => {
    selection.each(function(graphModel) {
      if (!viz) {
        viz = neo.viz(this, graphModel, layout, style);
        graphModel.on('updated', () => viz.update());
        viz.trigger = trigger;
      }
      return viz.update();
    });
  };

  chart.on = (event, callback) => {
    (callbacks[event] != null ? callbacks[event] : callbacks[event] = []).push(callback);
    return chart;
  };

  chart.layout = value => {
    if (!arguments.length) return layout;
    layout = value;
    return chart;
  };

  chart.style = value => {
    if (!arguments.length) return style.toSheet();
    style.importGrass(value);
    return chart;
  };

  chart.width = value => {
    if (!arguments.length) return viz.width;
    return chart;
  };

  chart.height = value => {
    if (!arguments.length) return viz.height;
    return chart;
  };

  chart.update = () => {
    viz.update();
    return chart;
  };

  return chart;
};

neo.layout = (() => {
  const _layout = {};
  _layout.force = () => {
    const _force = {};
    _force.init = render => {
      const forceLayout = {};
      const linkDistance = 60;
      const d3force = d3.layout.force().linkDistance(linkDistance).charge(-1000).gravity(0.3);
      const accelerateLayout = () => {
        let maxStepsPerTick = 100;
        const maxAnimationFramesPerSecond = 60;
        const maxComputeTime = 1000 / maxAnimationFramesPerSecond;
        const now = window.performance
          ? () => window.performance.now()
          : () => Date.now();
        const d3Tick = d3force.tick;
        return d3force.tick = (_this =>
          () => {
            const startTick = now();
            let step = maxStepsPerTick;
            while (step-- && now() - startTick < maxComputeTime) {
              if (d3Tick()) {
                maxStepsPerTick = 2;
                return true;
              }
            }
            render();
            return false;
        })(this);
      };
      accelerateLayout();
      forceLayout.update = (graph, size) => {
        const nodes = graph.nodes();
        const relationships = graph.relationships();
        const radius = nodes.length * linkDistance / (Math.PI * 2);
        const center = { x: size[0] / 2, y: size[1] / 2 };
        neo.utils.circularLayout(nodes, center, radius);
        return d3force.nodes(nodes).links(relationships).size(size).start();
      };
      forceLayout.drag = d3force.drag;
      return forceLayout;
    };
    return _force;
  };

  return _layout;
})();

neo.models.Node = (() => {
  function Node(id, labels, properties) {
    this.id = id;
    this.labels = labels;
    this.propertyMap = properties;
    this.propertyList = (() => {
      const _results = [];
      for (const key in properties) {
        if (!__hasProp.call(properties, key)) continue;
        const value = properties[key];
        _results.push({ key, value });
      }
      return _results;
    })();
  }

  Node.prototype.toJSON = () => this.propertyMap;

  Node.prototype.isNode = true;

  Node.prototype.isRelationship = false;

  return Node;
})();

neo.models.Relationship = (() => {
  function Relationship(id, source, target, type, properties) {
    this.id = id;
    this.source = source;
    this.target = target;
    this.type = type;
    this.propertyMap = properties;
    this.propertyList = (() => {
      const _ref = this.propertyMap;
      const _results = [];
      for (const key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        const value = _ref[key];
        _results.push({ key, value });
      }
      return _results;
    }).call(this);
  }

  Relationship.prototype.toJSON = () => this.propertyMap;

  Relationship.prototype.isNode = false;

  Relationship.prototype.isRelationship = true;

  return Relationship;
})();

neo.Renderer = (() => {
  function Renderer(opts) {
    if (opts == null) opts = {};
    neo.utils.extend(this, opts);
    if (this.onGraphChange == null) {
      this.onGraphChange = function() {};
    }
    if (this.onTick == null) {
      this.onTick = function() {};
    }
  }

  return Renderer;
})();

neo.style = (() => {
  const _style = storage => new GraphStyle(storage);

  _style.defaults = {
    autoColor: true,
    colors: [
      {
        color: '#DFE1E3',
        'border-color': '#D4D6D7',
        'text-color-internal': '#000'
      }, {
        color: '#BBDAFF',
        'border-color': '#BBBBFF',
        'text-color-internal': '#000'
      }, {
        color: '#CEF0FF',
        'border-color': '#ACF3FD',
        'text-color-internal': '#000'
      }, {
        color: '#B5FFFC',
        'border-color': '#A5FEEB',
        'text-color-internal': '#000'
      }, {
        color: '#B5FFC8',
        'border-color': '#A4F0B7',
        'text-color-internal': '#000'
      }, {
        color: '#CAFEB8',
        'border-color': '#A5FF8A',
        'text-color-internal': '#000'
      }, {
        color: '#B8E2EF',
        'border-color': '#8CD1E6',
        'text-color-internal': '#000'
      }, {
        color: '#CEDEF4',
        'border-color': '#D7D1F8',
        'text-color-internal': '#000'
      }, {
        color: '#E1CAF9',
        'border-color': '#E8C6FF',
        'text-color-internal': '#000'
      }, {
        color: '#F0C4F0',
        'border-color': '#FFCEFF',
        'text-color-internal': '#000'
      }, {
        color: '#FFCAF9',
        'border-color': '#FEA9F3',
        'text-color-internal': '#000'
      }, {
        color: '#DDCEFF',
        'border-color': '#C4ABFE',
        'text-color-internal': '#000'
      }
    ],
    style: {
      'node': {
        'diameter': '70px',
        'color': '#DFE1E3',
        'border-color': '#D4D6D7',
        'border-width': '2px',
        'text-color-internal': '#000',
        'caption': '{id}',
        'font-size': '8px'
      },
      'relationship': {
        'color': '#D4D6D7',
        'shaft-width': '1px',
        'font-size': '8px',
        'padding': '3px',
        'text-color-external': '#000',
        'text-color-internal': '#FFF'
      }
    },
    sizes: [
      {
        diameter: '10px'
      }, {
        diameter: '20px'
      }, {
        diameter: '30px'
      }, {
        diameter: '50px'
      }, {
        diameter: '80px'
      }
    ],
    arrayWidths: [
      {
        'shaft-width': '1px'
      }, {
        'shaft-width': '2px'
      }, {
        'shaft-width': '3px'
      }, {
        'shaft-width': '5px'
      }, {
        'shaft-width': '8px'
      }, {
        'shaft-width': '13px'
      }, {
        'shaft-width': '25px'
      }, {
        'shaft-width': '38px'
      }
    ]
  };

  const Selector = (() => {
    function Selector(selector) {
      const _ref = selector.indexOf('.') > 0 ? selector.split('.') : [selector, void 0];
      this.tag = _ref[0];
      this.klass = _ref[1];
    }

    Selector.prototype.toString = () => {
      let str = this.tag;
      if (this.klass != null) {
        str += "." + this.klass;
      }
      return str;
    };

    return Selector;
  })();

  const StyleRule = (() => {
    function StyleRule(selector, props) {
      this.selector = selector;
      this.props = props;
    }

    StyleRule.prototype.matches = function(selector) {
      if (this.selector.tag === selector.tag) {
        if (this.selector.klass === selector.klass || !this.selector.klass) {
          return true;
        }
      }
      return false;
    };

    StyleRule.prototype.matchesExact = function(selector) {
      return this.selector.tag === selector.tag && this.selector.klass === selector.klass;
    };

    return StyleRule;
  })();

  const StyleElement = (() => {
    function StyleElement(selector, data) {
      this.data = data;
      this.selector = selector;
      this.props = {};
    }

    StyleElement.prototype.applyRules = function(rules) {
      for (let _i = 0, _len = rules.length; _i < _len; _i++) {
        let rule = rules[_i];
        if (!(rule.matches(this.selector))) {
          continue;
        }
        neo.utils.extend(this.props, rule.props);
        break;
      }
      for (let _j = 0, _len1 = rules.length; _j < _len1; _j++) {
        let rule = rules[_j];
        if (!(rule.matchesExact(this.selector))) {
          continue;
        }
        neo.utils.extend(this.props, rule.props);
        break;
      }

      return this;
    };

    StyleElement.prototype.get = function(attr) {
      return this.props[attr] || '';
    };

    return StyleElement;
  })();

  const GraphStyle = (() => {
    function GraphStyle(storage) {
      this.storage = storage;
      this.rules = [];
      this.loadRules();
    }

    GraphStyle.prototype.selector = function(item) {
      return item.isNode
        ? this.nodeSelector(item)
        : item.isRelationship
          ? this.relationshipSelector(item)
          : null;
    };

    GraphStyle.prototype.calculateStyle = function(selector, data) {
      return new StyleElement(selector, data).applyRules(this.rules);
    };

    GraphStyle.prototype.forEntity = function(item) {
      return this.calculateStyle(this.selector(item), item);
    };

    GraphStyle.prototype.forNode = function(node) {
      if (node == null) node = {};

      const selector = this.nodeSelector(node);
      let _ref =  node.labels;
      if ((_ref != null ? _ref.length : void 0) > 0) {
        this.setDefaultStyling(selector);
      }
      return this.calculateStyle(selector, node);
    };

    GraphStyle.prototype.forRelationship = function(rel) {
      return this.calculateStyle(this.relationshipSelector(rel), rel);
    };

    GraphStyle.prototype.findAvailableDefaultColor = function() {
      const usedColors = {};
      const _ref = this.rules;
      for (let _i = 0, _len = _ref.length; _i < _len; _i++) {
        const rule = _ref[_i];
        if (rule.props.color != null) {
          usedColors[rule.props.color] = true;
        }
      }
      const _ref1 = _style.defaults.colors;
      for (let _j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        const defaultColor = _ref1[_j];
        if (usedColors[defaultColor.color] == null) {
          return neo.utils.copy(defaultColor);
        }
      }
      return neo.utils.copy(_style.defaults.colors[0]);
    };

    GraphStyle.prototype.setDefaultStyling = function(selector) {
      let rule = this.findRule(selector);
      if (_style.defaults.autoColor && (rule == null)) {
        rule = new StyleRule(selector, this.findAvailableDefaultColor());
        this.rules.push(rule);
        return this.persist();
      }
    };

    GraphStyle.prototype.change = function(item, props) {
      const selector = this.selector(item);
      let rule = this.findRule(selector);
      if (rule == null) {
        rule = new StyleRule(selector, {});
        this.rules.push(rule);
      }
      neo.utils.extend(rule.props, props);
      this.persist();
      return rule;
    };

    GraphStyle.prototype.destroyRule = function(rule) {
      const idx = this.rules.indexOf(rule);
      if (idx != null) {
        this.rules.splice(idx, 1);
      }
      return this.persist();
    };

    GraphStyle.prototype.findRule = function(selector) {
      let rule;
      const _ref = this.rules;
      for (let _i = 0, _len = _ref.length; _i < _len; _i++) {
        const r = _ref[_i];
        if (r.matchesExact(selector)) {
          rule = r;
        }
      }
      return rule;
    };

    GraphStyle.prototype.nodeSelector = function(node) {
      if (node == null) node = {};
      let selector = 'node';
      let _ref = node.labels;
      if ((_ref != null ? _ref.length : void 0) > 0) {
        selector += "." + node.labels[0];
      }
      return new Selector(selector);
    };

    GraphStyle.prototype.relationshipSelector = function(rel) {
      if (rel == null) rel = {};
      let selector = 'relationship';
      if (rel.type != null) {
        selector += "." + rel.type;
      }
      return new Selector(selector);
    };

    GraphStyle.prototype.importGrass = function(string) {
      try {
        const rules = this.parse(string);
        this.loadRules(rules);
        return this.persist();
      } catch (_error) {
        console.error(_error);
      }
    };

    GraphStyle.prototype.loadRules = function(data) {
      if (!neo.utils.isObject(data)) {
        data = _style.defaults.style;
      }
      this.rules.length = 0;
      for (const rule in data) {
        const props = data[rule];
        this.rules.push(new StyleRule(new Selector(rule), neo.utils.copy(props)));
      }
      return this;
    };

    GraphStyle.prototype.parse = function(string) {
      const chars = string.split(''), rules = {};
      let insideString = false, insideProps = false, keyword = "", props = "";
      for (let _i = 0, _len = chars.length; _i < _len; _i++) {
        const c = chars[_i];
        let skipThis = true;
        switch (c) {
          case "{":
            if (!insideString) {
              insideProps = true;
            } else {
              skipThis = false;
            }
            break;
          case "}":
            if (!insideString) {
              insideProps = false;
              rules[keyword] = props;
              keyword = "";
              props = "";
            } else {
              skipThis = false;
            }
            break;
          case "'":
          case "\"":
            insideString ^= true;
            break;
          default:
            skipThis = false;
        }
        if (skipThis) {
          continue;
        }
        if (insideProps) {
          props += c;
        } else {
          if (!c.match(/[\s\n]/)) {
            keyword += c;
          }
        }
      }
      for (const k in rules) {
        const v = rules[k];
        rules[k] = {};
        const _ref = v.split(';');
        for (let _j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          const prop = _ref[_j];
          const _ref1 = prop.split(':');
          const key = _ref1[0];
          const val = _ref1[1];
          if (!(key && val)) {
            continue;
          }
          rules[k][key != null ? key.trim() : void 0] = val != null ? val.trim() : void 0;
        }
      }
      return rules;
    };

    GraphStyle.prototype.persist = function() {
      const _ref = this.storage;
      return _ref != null ? _ref.add('grass', JSON.stringify(this.toSheet())) : void 0;
    };

    GraphStyle.prototype.resetToDefault = function() {
      this.loadRules();
      return this.persist();
    };

    GraphStyle.prototype.toSheet = function() {
      const sheet = {};
      const _ref = this.rules;
      for (let _i = 0, _len = _ref.length; _i < _len; _i++) {
        const rule = _ref[_i];
        sheet[rule.selector.toString()] = rule.props;
      }
      return sheet;
    };

    GraphStyle.prototype.toString = function() {
      let str = "";
      const _ref = this.rules;
      for (let _i = 0, _len = _ref.length; _i < _len; _i++) {
        const r = _ref[_i];
        str += r.selector.toString() + " {\n";
        const _ref1 = r.props;
        for (const k in _ref1) {
          let v = _ref1[k];
          if (k === "caption") {
            v = "'" + v + "'";
          }
          str += "  " + k + ": " + v + ";\n";
        }
        str += "}\n\n";
      }
      return str;
    };

    GraphStyle.prototype.nextDefaultColor = 0;

    GraphStyle.prototype.defaultColors = function() {
      return neo.utils.copy(_style.defaults.colors);
    };

    GraphStyle.prototype.interpolate = function(str, id, properties) {
      return str.replace(/\{([^{}]*)\}/g, (a, b) => {
        const r = properties[b] || id;
        return typeof r === 'string' || typeof r === 'number'
          ? r
          : a;
      });
    };

    return GraphStyle;
  })();

  return _style;
})();

neo.viz = function(el, graph, layout, style) {
  const viz = { style }, geometry = new NeoD3Geometry(style);
  el = d3.select(el);

  viz.trigger = () => {};

  const onNodeClick = (_this => {
    return node => viz.trigger('nodeClicked', node);
  })(this);

  const onNodeDblClick = (_this => {
    return node => viz.trigger('nodeDblClicked', node);
  })(this);

  const onRelationshipClick = (_this => {
    return relationship => viz.trigger('relationshipClicked', relationship);
  })(this);

  const render = () => {
    let renderer;
    geometry.onTick(graph);

    const nodeGroups = el.selectAll("g.node").attr("transform", function(node) {
      return "translate(" + node.x + "," + node.y + ")";
    });

    const _ref = neo.renderers.node;
    for (let _i = 0, _len = _ref.length; _i < _len; _i++) {
      renderer = _ref[_i];
      nodeGroups.call(renderer.onTick, viz);
    }

    const relationshipGroups = el.selectAll("g.relationship");
    const _ref1 = neo.renderers.relationship;
    const _results = [];
    for (let _j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      renderer = _ref1[_j];
      _results.push(relationshipGroups.call(renderer.onTick, viz));
    }
    return _results;
  };

  const force = layout.init(render);

  viz.update = () => {
    if (!graph) return;

    const height = (() => {
      try {
        return parseInt(el.style('height').replace('px', ''), 10);
      } catch (_error) {}
    })();

    const width = (() => {
      try {
        return parseInt(el.style('width').replace('px', ''), 10);
      } catch (_error) {}
    })();

    const layers = el.selectAll("g.layer").data(["relationships", "nodes"]);
    layers.enter().append("g").attr("class", d => "layer " + d);

    const nodes = graph.nodes();
    const relationships = graph.relationships();
    const relationshipGroups = el.select("g.layer.relationships").selectAll("g.relationship").data(relationships, d => d.id);
    relationshipGroups.enter().append("g").attr("class", "relationship").on("click", onRelationshipClick);

    geometry.onGraphChange(graph);

    let renderer;
    const _ref = neo.renderers.relationship;
    for (let _i = 0, _len = _ref.length; _i < _len; _i++) {
      renderer = _ref[_i];
      relationshipGroups.call(renderer.onGraphChange, viz);
    }
    relationshipGroups.exit().remove();

    const nodeGroups = el.select("g.layer.nodes").selectAll("g.node").data(nodes, d => d.id);
    nodeGroups.enter().append("g").attr("class", "node").call(force.drag).call(clickHandler);
    const _ref1 = neo.renderers.node;
    for (let _j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      renderer = _ref1[_j];
      nodeGroups.call(renderer.onGraphChange, viz);
    }
    nodeGroups.exit().remove();
    return force.update(graph, [width, height]);
  };
  const clickHandler = neo.utils.clickHandler();
  clickHandler.on('click', onNodeClick);
  clickHandler.on('dblclick', onNodeDblClick);
  return viz;
};

neo.utils.circularLayout = (nodes, center, radius) => {
  const unlocatedNodes = nodes.filter(node => !((node.x != null) && (node.y != null))), _results = [];
  let _i;
  for (let i = _i = 0, _len = unlocatedNodes.length; _i < _len; i = ++_i) {
    const n = unlocatedNodes[i];
    n.x = center.x + radius * Math.sin(2 * Math.PI * i / unlocatedNodes.length);
    _results.push(n.y = center.y + radius * Math.cos(2 * Math.PI * i / unlocatedNodes.length));
  }
  return _results;
};

neo.utils.distributeCircular = (arrowAngles, minSeparation) => {
  const list = [], _ref = arrowAngles.floating, result = {};
  let angle, key, _i, _k;
  for (key in _ref) {
    angle = _ref[key];
    list.push({ key, angle});
  }

  list.sort((a, b) => a.angle - b.angle);

  const runsOfTooDenseArrows = [];
  const length = (startIndex, endIndex) =>
    startIndex < endIndex
      ? endIndex - startIndex + 1
      : endIndex + list.length - startIndex + 1;

  angle = (startIndex, endIndex) =>
    startIndex < endIndex
      ? list[endIndex].angle - list[startIndex].angle
      : 360 - (list[startIndex].angle - list[endIndex].angle);

  const tooDense = (startIndex, endIndex) => angle(startIndex, endIndex) < length(startIndex, endIndex) * minSeparation;

  const wrapIndex = index =>
    index === -1
      ? list.length - 1
      : index >= list.length
        ? index - list.length
        : index;

  const wrapAngle = angle =>
    angle >= 360 ? angle - 360 : angle;

  const expand = (startIndex, endIndex) => {
    if (length(startIndex, endIndex) < list.length) {
      if (tooDense(startIndex, wrapIndex(endIndex + 1))) return expand(startIndex, wrapIndex(endIndex + 1));
      if (tooDense(wrapIndex(startIndex - 1), endIndex)) return expand(wrapIndex(startIndex - 1), endIndex);
    }
    return runsOfTooDenseArrows.push({ start: startIndex, end: endIndex });
  };

  for (let i = _i = 0, _ref1 = list.length - 2; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
    if (tooDense(i, i + 1)) expand(i, i + 1);
  }

  for (let _j = 0, _len = runsOfTooDenseArrows.length; _j < _len; _j++) {
    const run = runsOfTooDenseArrows[_j];
    const center = list[run.start].angle + angle(run.start, run.end) / 2;
    const runLength = length(run.start, run.end);
    for (let i = _k = 0, _ref2 = runLength - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
      const rawAngle = center + (i - (runLength - 1) / 2) * minSeparation;
      result[list[wrapIndex(run.start + i)].key] = wrapAngle(rawAngle);
    }
  }
  const _ref3 = arrowAngles.floating;

  for (key in _ref3) {
    angle = _ref3[key];
    if (!result[key]) result[key] = arrowAngles.floating[key];
  }
  return result;
};

neo.utils.clickHandler = () => {
  const cc = selection => {
    const dist = (a, b) => Math.sqrt(Math.pow(a - b[0], 2));
    const tolerance = 5;
    let wait = null;

    selection.on("mousedown", e => {
      d3.event = e;
      d3.event.fixed = true;
      return +new Date();
    });

    return selection.on("mouseup", e => {
      d3.event = e;
      if (dist(void 0, d3.mouse(document.body)) > tolerance) {
      } else {
        if (wait) {
          window.clearTimeout(wait);
          wait = null;
          return event.dblclick(d3.event);
        } else {
          return wait = window.setTimeout((ev => {
            return () => {
              event.click(ev);
              return wait = null;
            };
          })(d3.event), 250);
        }
      }
    });
  };
  const event = d3.dispatch("click", "dblclick");
  return d3.rebind(cc, event, "on");
};

neo.utils.measureText = (() => {
  const measureUsingCanvas = (text, font) => {
    const canvasSelection = d3.select('canvas#textMeasurementCanvas').data([this]);
    canvasSelection.enter().append('canvas').attr('id', 'textMeasurementCanvas').style('display', 'none');
    const canvas = canvasSelection.node();
    const context = canvas.getContext('2d');
    context.font = font;
    return context.measureText(text).width;
  };

  const cache = (() => {
    const cacheSize = 10000, map = {}, list = [];
    return (key, calc) => {
      if (map[key]) {
        return map[key];
      } else {
        const result = calc();
        if (list.length > cacheSize) {
          delete map[list.splice(0, 1)];
          list.push(key);
        }
        return map[key] = result;
      }
    };
  })();

  return (text, fontFamily, fontSize) => {
    const font = `normal normal normal ${fontSize}px/normal ${fontFamily}`;
    return cache(text + font, () => measureUsingCanvas(text, font));
  };
})();

(() => {
  const noop = () => {};

  const nodeOutline = new neo.Renderer({
    onGraphChange: (selection, viz) => {
      const circles = selection.selectAll('circle.outline').data(node => [node]);
      circles.enter().append('circle').classed('outline', true).attr({ cx: 0, cy: 0 });
      circles.attr({
        r: node => node.radius,
        fill: node => viz.style.forNode(node).get('color'),
        stroke: node => viz.style.forNode(node).get('border-color'),
        'stroke-width': node => viz.style.forNode(node).get('border-width')
      });
      return circles.exit().remove();
    },
    onTick: noop
  });

  const nodeCaption = new neo.Renderer({
    onGraphChange: (selection, viz) => {
      const text = selection.selectAll('text').data(node => node.caption);
      text.enter().append('text').attr({
        'text-anchor': 'middle',
        'font-weight': 'normal',
        'stroke': '#FFFFFF',
        'stroke-width' : '0'
      });
      text.text(line => line.text)
        .attr('y', line => line.baseline)
        .attr('font-size', line => viz.style.forNode(line.node).get('font-size'))
        .attr('stroke', line => viz.style.forNode(line.node).get('color'))
        .attr('fill', line => viz.style.forNode(line.node).get('text-color-internal'));
      return text.exit().remove();
    },
    onTick: noop
  });

  const nodeOverlay = new neo.Renderer({
    onGraphChange: selection => {
      const circles = selection.selectAll('circle.overlay').data(node => node.selected ? [node] : []);
      circles.enter().insert('circle', '.outline').classed('ring', true).classed('overlay', true).attr({
        cx: 0, cy: 0, fill: '#f5F6F6', stroke: 'rgba(151, 151, 151, 0.2)', 'stroke-width': '3px' });
      circles.attr({ r: node => node.radius + 6 });
      return circles.exit().remove();
    },
    onTick: noop
  });

  const arrowPath = new neo.Renderer({
    onGraphChange: (selection, viz) => {
      const paths = selection.selectAll('path').data(rel => [rel]);
      paths.enter().append('path');
      paths.attr('fill', rel => viz.style.forRelationship(rel).get('color')).attr('stroke', 'none');
      return paths.exit().remove();
    },
    onTick: selection =>
      selection.selectAll('path').attr('d', d => d.arrowOutline)
        .attr('transform', d => isNaN(d.startPoint.x) || isNaN(d.startPoint.y)
          ? null : "translate(" + d.startPoint.x + " " + d.startPoint.y + ") rotate(" + d.angle + ")")
  });

  const relationshipType = new neo.Renderer({
    onGraphChange: (selection, viz) => {
      const texts = selection.selectAll("text").data(rel => [rel]);
      texts.enter().append("text").attr({ "text-anchor": "middle" });
      texts.attr('font-size', rel => viz.style.forRelationship(rel).get('font-size'))
        .attr('fill', rel => viz.style.forRelationship(rel).get('text-color-' + rel.captionLayout));
      return texts.exit().remove();
    },
    onTick: (selection, viz) =>
      selection.selectAll('text')
        .attr('x', rel => isNaN(rel.midShaftPoint.x) ? null : rel.midShaftPoint.x)
        .attr('y', rel => isNaN(rel.midShaftPoint.y) ? null : rel.midShaftPoint.y + parseFloat(viz.style.forRelationship(rel).get('font-size')) / 2 - 1)
        .attr('transform', rel => isNaN(rel.midShaftPoint.x) || isNaN(rel.midShaftPoint.y) ? null :  "rotate(" + rel.textAngle + " " + rel.midShaftPoint.x + " " + rel.midShaftPoint.y + ")")
        .text(rel => rel.shortCaption)
  });

  const relationshipOverlay = new neo.Renderer({
    onGraphChange: selection => {
      const rects = selection.selectAll("rect").data(rel => [rel]);
      const band = 20;
      rects.enter().append('rect').classed('overlay', true).attr('fill', 'yellow').attr('x', 0).attr('y', -band / 2).attr('height', band);
      rects.attr('opacity', rel => rel.selected ? 0.3 : 0);
      return rects.exit().remove();
    },
    onTick: selection =>
      selection.selectAll('rect').attr('width', d => d.arrowLength > 0 ? d.arrowLength : 0)
        .attr('transform', d => isNaN(d.startPoint.x) || isNaN(d.startPoint.y)
          ? null : "translate(" + d.startPoint.x + " " + d.startPoint.y + ") rotate(" + d.angle + ")")
  });

  neo.renderers.node.push(nodeOutline);
  neo.renderers.node.push(nodeCaption);
  neo.renderers.node.push(nodeOverlay);
  neo.renderers.relationship.push(arrowPath);
  neo.renderers.relationship.push(relationshipType);
  return neo.renderers.relationship.push(relationshipOverlay);
})();

export default neo;
